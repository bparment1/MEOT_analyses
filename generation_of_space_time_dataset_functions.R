########################################       Generation of space-time dataset       #######################################
########################################### For Testing MSSA-MEOT and S-T mode PCA #####################################
#This script contains function to generate synthetic space time dataset in R to test EOT,MEOT,PCA and MSSA.
#Space-time series can be generated by combining a set of spatial patterns and temporal patterns. 
#Parent code to run functions is found in "generation_of_space_time_dataset_09122013v5.R"
#AUTHORS:Benoit Parmentier                                             
#DATE: 10/16/2013                                                                                
#PROJECT: Clark Labs, MEOT, time series                                  
###################################################################################################

## The current script contains 11 functions:
#Add more explantions later on...
#[1] "adding_sptatial_structure"        #create a number of spatial patterns for one image              
#[2] "adding_temporal_structure"        #create a number of temporal pattern for given time series exten             
#[3] "combine_space_time_structure"     # combine temporal structure and spatial structure             
#[4] "create_idrisi_rgf"                       
#[5] "create_raster_list_from_file_pat"         
#[6] "generate_moving_space_time_structure" #create a sequence of images for a spatio-temporal pattern given a trajectory    
#[7] "generate_raster_region" #create a raster image with columns and rows and given projection                 
#[8] "generate_spatial_trajectory"  #create a sequence of positions (trajectory) for the centroid of the moving space-time structure            
#[9] "generate_stack_raster" # create a stack of images given a spatial pattern (replicate images)                   
#[10] "plot_time_space_pattern"                                              
#[11] "sine_structure_fun"

###Loading R library and packages                                                      

library(gtools)                                        # loading some useful tools 
library(sp)
library(raster)
library(rasterVis)
library(rgdal)
library(vegan) 
library(zoo)

##### Functions used in the script: "generation_of_space_time_dataset_09042013v5.R" #####

##Function to generate spatial image

generate_raster_region <-function(j,list_param){
  #This....
  #Arguments: no of image, no of rows and columns, projection, range of value to be used, distribution, output prefix, and output directory
  #Output: raster image in IDRISI format
  
  ## Parse input arguments
  
  j <- list_param$j
  col <- list_param$col
  row <- list_param$row
  proj_str <- list_param$proj_str
  range_val <- list_param$range_val
  mean_val <- list_param$mean_val
  sd_val <- list_param$sd_val
  distribution_val_i <- list_param$distribution_val_i
  out_suffix <- list_param$out_suffix
  out_dir <-list_param$out_dir
  list_param$NA_flag_val
  
  ## Start #
  
  if(distribution_val_i=="none"){
    pix_values <- rep(1,row*col)
  }
  if(distribution_val_i=="unif"){
    pix_values <- runif(row*col)
  }
  if(distribution_val_i=="norm"){
    pix_values <- rnorm(n=row*col,mean=mean_val,sd=sd_val)
  }
  r<-raster(nrows=row, ncols=col,crs=proj_str,xmn=0, xmx = col, ymn=0, ymx=row)
  r <- setValues(r,pix_values)
  
  #Write out the raster defining the region
  raster_name<-file.path(out_dir,paste("reg_raster","_",row, "r_", col,"c_",out_suffix, sep=""))
  writeRaster(r, filename=raster_name,NAflag=NA_flag_val,bylayer=FALSE,bandorder="BSQ",overwrite=TRUE)  #Writing the data in a raster file format...  
  #return raster defining the extent and basis layer!!!
  return(r)
}

#Function to generate spatial structure
adding_sptatial_structure  <-function(j,list_param){
  
  #This....
  #Arguments: no of image, no of rows and columns, projection, range of value to be used, type of spatial pattern, output prefix, and output directory
  #Output: raster image in IDRISI format  
  #TO DO: modify for memory efficiency, write out individual raster images if necessary. 
  #Functions used in this code:
  
  sine_structure_fun <-function(x,T,phase,a,b){
    #Create sine for a one dimensional series
    #Note that sine function uses radian unit.
    #a=amplitude
    #b=mean or amplitude 0 of the series
    #T= stands for period definition
    #phase=phase angle (in radian!!)
    
    y <- a*sin((x*pi/T)+ phase) + b
  }
  
  ## Parse input arguments
  
  j <- list_param$j
  r <- list_param$r
  proj_str <- list_param$proj_str
  range_val <- list_param$range_val
  NA_flag_val <- list_param$NA_flag_val
  file_format <- list_param$file_format #".tif" or ".rst" for the time being
  #type_spatialstructure <- list_param$type_spatialstructure
  out_suffix <- list_param$out_suffix
  out_dir <-list_param$out_dir
  r <- list_param$r
  row <- nrow(r)  
  col<- ncol(r)
  
  ### Start #####
  
  type_spatialstructure <- character (length=15) #empty char vector to store names of spatial structures/raster layers 
  #Generate first spatial pattern: constant square   
  spstr<- r  
  type_spatialstructure[1] <- "constant_sqr"
  pix_values <- min(range_val)
  spstr <- setValues(spstr,pix_values)
  spstr[1:(row/2), 1:(col/2)] <- max(range_val)
  spstr[(row/2)+1:row, (col/2)+1:col] <- max(range_val)
  r1 <- spstr 
  
  #Generate spatial pattern 2: sine diagonal   
  type_spatialstructure[2] <- "sine_diag1" 
  pix_values <- min(range_val)
  spstr <- setValues(spstr,pix_values)
  x.coord <- rep(1:col, each=col)
  y.coord <- rep(1:row, times=row)
  xy <- data.frame(x.coord, y.coord)
  xy.dist <- dist(xy)
  pcnm.axes <- pcnm(xy.dist)$vectors
  z.value <- pcnm.axes[,1]*100 + rnorm(row*col, min(range_val), max(range_val))
  spstr[] <- z.value
  r2 <- spstr
  
  #Generate spatial pattern 3: trend in x    
  type_spatialstructure[3] <-"trend_x"
  u <-xFromCol(r,colnr=1:col)
  a<- 2 #slope
  b<- -1 #intercept
  ux <-  a*u + b  
  ux <-rep(ux,time=row)  
  r3<-setValues(r,ux)  
  
  #Generate spatial pattern 4: trend in y    
  type_spatialstructure[4] <-"trend_y"
  r4 <-t(r3)
  
  #Generate spatial pattern 5:     
  type_spatialstructure[5] <- "periodic_x1"
  u <- xFromCol(r,colnr=1:col)
  a<- 2 #amplitude in this case
  b<- 0
  T<- col
  phase <- 0
  ux <- sine_structure_fun(u,T,phase,a,b)
  ux <-rep(ux,time=row)  
  r5<-setValues(r,ux)  
  plot(r5)
  
  #Generate spatial pattern6:  
  type_spatialstructure[6] <- "periodic_y1"
  r6 <-t(r5)
  
  #Generate spatial pattern7:  
  type_spatialstructure[7] <- "periodic_xy1"
  r7 <- r5 + r6
  
  #Generate spatial pattern 8:     
  type_spatialstructure[8] <- "periodic_x2"
  u <- xFromCol(r,colnr=1:col)
  a<- 2 #amplitude in this case
  b<- 0
  T<- round(col/2)
  phase <- 0  
  ux <- sine_structure_fun(u,T,phase,a,b)
  ux <-rep(ux,time=row)  
  r8 <-setValues(r,ux)  

  #Generate spatial pattern 9:  
  type_spatialstructure[9] <- "periodic_y2"
  r9 <- t(r8)
  
  #Generate spatial pattern 10:  
  type_spatialstructure[10] <- "periodic_xy2"
  r10 <- r8 + r9
    
  #Generate spatial pattern 11:     
  type_spatialstructure[11] <- "periodic_x3"
  u <- xFromCol(r,colnr=1:col)
  a<- 2 #amplitude in this case, should be an argument of the function
  b<- 0
  T<- round(col/3)
  phase <- 0  
  ux <- sine_structure_fun(u,T,phase,a,b)
  ux <-rep(ux,time=row)  
  r11 <-setValues(r,ux)  
  
  #Generate spatial pattern 12:  
  type_spatialstructure[12] <- "periodic_y3"
  r12 <- t(r11)
  
  #Generate spatial pattern 13:  
  type_spatialstructure[13] <- "periodic_xy3"
  r13 <- r11 + r12
  
  #Generate spatial pattern 14:  
  type_spatialstructure[14] <- "constant" #This may contain randomness!!
  r14 <-r 
  
  #Generate spatial pattern 15: trend in xy, diagonal   
  type_spatialstructure[15] <-"trend_xy"
  r15 <- r3 + r4
  
  #TO DO later - Generate user defined patter: using a,b,phase and other inputs
  
  #Prepare stack to return object
  r_spat <-stack(r1,r2,r3,r4,r5,r6,r7,r8,r9,r10,r11,r12,r13,r14,r15)
  #names(r_spat) <- type_Spatialstructure
  layerNames(r_spat) <- type_spatialstructure
  
  #Write out spatial patterns
  if(file_format==".rst"){
    for (i in 1:nlayers(r_spat)){
      rast <-subset(r_spat,i)
      raster_name<-paste("raster","_",row, "r_", col,"c_","r_spat_s_",i,"_",
                         type_spatialstructure[i],"_",out_suffix,file_format, sep="")
      writeRaster(rast, NAflag=NA_flag_val,filename=file.path(out_dir,raster_name)
                  ,bylayer=FALSE,bandorder="BSQ",overwrite=TRUE)
    }
  }
  #now write out stack...
  if(file_format==".tif"){
  raster_name<-paste("raster","_",row, "r_", col,"c_","r_spat_s","_",out_suffix,file_format, sep="")
  writeRaster(r_spat, NAflag=NA_flag_val,filename=raster_name,bylayer=TRUE,bandorder="BSQ",overwrite=TRUE)   
  }

  return(r_spat)
}

#Function ....
adding_temporal_structure <-function(list_param){
  #This....
  #Arguments: no of image, no of rows and columns, projection, range of value to be used, type of spatial pattern, output prefix, and output directory
  #Output: raster image in IDRISI format  
  
  ##Functions used:
  
  temp_structure_fun <-function(x,T,phase){
    y <-sin((x*pi/T)+ phase)
  }
  
  ## Parse input arguments
  #j <- list_param$j
  nt <- list_param$nt
  phase <- list_param$phase
  temp_periods <- list_param$temp_periods
  temp_period_quadrature <- list_param$temp_period_quadrature
  
  ### Start #####
  
  #type_temporalstructure <- character (length=6)
  x<- as.numeric(1:nt)
  
  # Generate temporal signal with periodic signal
  
  y1_list<-vector("list",length=length(temp_periods))
  for (i in 1:length(temp_periods)){
    T<-temp_periods[i]
    y1_list[[i]] <- temp_structure_fun(x,T,phase)
  }
  names(y1_list) <- paste("t_period",temp_periods,sep="_")
  # Generate periodic Quadrature:
  
  T <- temp_period_quadrature
  y2_list<-vector("list",length=length(temp_periods))
  y2_list[[1]] <- temp_structure_fun(x,T,pi/2)
  y2_list[[2]] <- temp_structure_fun(x,T,0)
  
  y2<-y2_list[[1]] + y2_list[[2]]
  
  # Generate temporal trends
  a<- 0.1
  b<- 0
  y3 <-  a*x + b  
  
  # Generate temporal temporal randomness
  y4 <- runif(nt) 
  
  y5<- rnorm(nt)
  
  #Prepare return object
  dfrm1 <-do.call(cbind,y1_list)
  dfrm2 <- do.call(cbind,list(quadrature=y2,trend=y3,unif=y4,norm=y5))
  temp_pattern_dfrm <- (cbind(dfrm1,dfrm2)) #data.frame containing temporal patterns...
  temp_pattern_dfrm<-as.data.frame(temp_pattern_dfrm)
  #head(temp_pattern_dfrm)
  file_name<-paste("table_temporal_patterns","_",out_suffix,".txt",sep="")
  write.table(temp_pattern_dfrm,file=file_name,sep=",")
  
  return(temp_pattern_dfrm)
}

#generate stack given a raster image, this replicates the original image...
generate_stack_raster<-function(r,n_stack){
  pix_vals <-getValues(r)
  list_r<-vector("list",length=n_stack)
  for (i in 1:n_stack){
    list_r[[i]]<-r
  }
  r_stack<-stack(list_r)
}

#Function to combine time and space structure, given a stack of value and temporal index
combine_space_time_structure <-function(temp_pattern,r_stack,out_suffix,NA_flag_val,file_format,out_dir,operation="addition"){
  #modify later for efficiency if needed, this is a small image!!!
  
  #create output dir:
  
  out_dir <-paste("",out_suffix,sep="") #add string later  
  if (!file.exists(out_dir)){    #create output directory if necessary...
    dir.create(out_dir)
    #} else{
    #  out_dir <-paste(out_dir..)
  }
    
  rast_ref <- raster(r_stack,1)
  r_list <-vector("list",length=nlayers(r_stack)) #contain rasters...
  list_raster_name <-vector("list",length=nlayers(r_stack)) #contain rasters...
  
  names(r_list) <- paste("ts",1:nlayers(r_stack),sep="_") #use names in new raster package
  for (k in 1:nlayers(r_stack)){
    pix_vals <-getValues(subset(r_stack,k))
    if(operation=="multiplication"){
      r_comb <- setValues(rast_ref,pix_vals*temp_pattern[k]) 
    }
    if(operation=="addition"){
      r_comb <- setValues(rast_ref,pix_vals+temp_pattern[k]) 
    }
    r_list[[k]] <- r_comb
    if(file_format==".rst"){
      raster_name<-paste("raster","_",row, "r_", col,"c_","ts_",k,"_",out_suffix,file_format, sep="")
      list_raster_name[[k]] <- file.path(out_dir,raster_name)
      writeRaster(r_comb, NAflag=NA_flag_val,filename=file.path(out_dir,raster_name)
                  ,bylayer=FALSE,bandorder="BSQ",overwrite=TRUE)
    }
  }
  r_temp <- stack(r_list)
  #dat_list<-c(as.integer(length(list_raster_name)),unlist(list_raster_name))
  #writeLines(dat_list,con=paste(out_suffix_s,".rgf",sep=""))
  
  #now write out stack...
  if(file_format==".tif"){
    raster_name<-paste("raster","_",row, "r_", col,"c_","ts_",k,"_",out_suffix,file_format, sep="")
    #writeRaster(r_comb, NAflag=NA_flag_val,filename=raster_name,bylayer=FALSE,bandorder="BSQ",overwrite=TRUE)
    writeRaster(r_temp, NAflag=NA_flag_val,filename=file.path(out_dir,raster_name),
                bylayer=TRUE,bandorder="BSQ",overwrite=TRUE)   
  }
  return(r_temp)
}

#Add moving spatial pattern function here...
#...
#combine sine in x and y in small window
#Create sequence with position on a circle...(if 12, divide circle in 12 location)
#combine sequence with r stack with specific time event...
#generate_moving_space_time_structure <-function(rast_ref,rast_pattern="",temp_event,period,out_suffix,NA_flag_val,file_format,option="addition"){
generate_moving_space_time_structure <-function(list_param){
  #This function produces a sequence of moving patterns given temporal profile and trajectory.
  #The default option is circular movement of a quarter of the original reference raster image.
  #Inputs:
  #
  #
  #Author: Benoit Parmentier
  #Date: 09/04/2013
  
  sine_structure_fun <-function(x,T,phase,a,b){
    #Create sine for a one dimensional series
    #Note that sine function uses radian unit.
    #a=amplitude
    #b=mean or amplitude 0 of the series
    #T= stands for period definition
    #phase=phase angle (in radian!!)
    
    y <- a*sin((x*pi/T)+ phase) + b
  }
  
  ## Parse input arguments
  
  r_stack <- list_param$r_stack
  temp_period<-list_param$temp_period
  period <- list_param$period
  NA_flag_val <- list_param$NA_flag_val
  file_format <- list_param$file_format #".tif" or ".rst" for the time being
  #type_spatialstructure <- list_param$type_spatialstructure
  out_suffix <- list_param$out_suffix
  out_dir <-list_param$out_dir
  rast_pattern <- list_param$rast_pattern #moving spatial pattern provided
  A_seq <- list_param$A_seq
  trajectory <- list_param$trajectory
    
  #moving spatial pattern provided
  rast_ref <-subset(r_stack,1)
  row_ref <- nrow(rast_ref)  
  col_ref <- ncol(rast_ref)
  proj_str <- projection(rast_ref)
  
  ### Step 1: Generate default spatial pattern or used raster provided:  
  
  ## Later add option to give one specific spatial pattern...
  if(is.null(rast_pattern)){
    row <- round(row_ref/2)
    col <- round(col_ref/2)
    
    pix_values <- rep(1,row*col)
    
    r<-raster(nrows=row, ncols=col,crs=proj_str,xmn=0, xmx = col, ymn=0, ymx=row)
    r <- setValues(r,pix_values)
    
    u <- xFromCol(r,colnr=1:col)
    a<- 2 #amplitude in this case
    b<- 0
    T<- round(col)
    phase <- 0  
    ux <- sine_structure_fun(u,T,phase,a,b)
    ux <-rep(ux,time=row)  
    r8 <-setValues(r,ux)  
    plot(r8)
    #Generate spatial pattern 9:  
    r9 <- t(r8)
    #Generate spatial pattern 10:  
    r10 <- r8 + r9
    levelplot(r10)
    
    #### end of generate spatial pattern  
  }else{
    r10<-rast_pattern
  }
  
  ##Step 2 generate spatial trajectory
  
  #Can be an option for later ...
  
  if(is.null(trajectory)){
    #Create unit circle
    
    T1 <- period
    
    x <-seq(-pi,pi,by=2*pi/360)
    x1<-sin(x)
    x2<-sin(x-pi/2)
    n_step <- length(x)/T1
        
    x1 <- x1[ seq(1,length(x1),n_step )]
    x2 <- x2[ seq(1,length(x2),n_step )]
    
    x1 <- x1*col_ref/4  #rayon (radius) will be col_ref/4
    x2 <- x2*col_ref/4
    
    u1 <- x1 + col_ref/2
    v1 <- x2 + row_ref/2
  
    #rayon <- sqrt(u1^2 + v1^2) #equation for a circle radius
    #rayon must be 15 if col_ref and row_ref are equal to 60
            
    peak <- data.frame(z=rep(2,length(v1)))
    circle <- SpatialPointsDataFrame(coords=cbind(u1,v1),data=peak)  #First put r10 at 0,0 (left botton corner) #This is already the case
    
    trajectory <- circle #This is the circular trajectory
    
    ## Step 3: generate sequence: if period>12 then it will spread over more than a year...
    
    #now convert to local coordinates for pattern image
    extent_pat <- extent(r10)
    
    centroid_y_pat <- (ymax(extent_pat)- ymin(extent_pat))/2
    centroid_x_pat <- (xmax(extent_pat)- xmin(extent_pat))/2
    
    coords_locs<-coordinates(circle)
    coords_locs[,1] <- coords_locs[,1] - centroid_x_pat
    coords_locs[,2] <- coords_locs[,2] - centroid_y_pat
    
  }
  
  #if trajectory provided, use it
  if(!is.null(trajectory)){
    ## Step 3: generate sequence: if period>12 then it will spread over more than a year...
    
    #now convert to local coordinates for pattern image
    extent_pat <- extent(r10)
    
    centroid_y_pat <- (ymax(extent_pat)- ymin(extent_pat))/2
    centroid_x_pat <- (xmax(extent_pat)- xmin(extent_pat))/2
    
    coords_locs<-coordinates(trajectory)
    coords_locs[,1] <- coords_locs[,1] - centroid_x_pat
    coords_locs[,2] <- coords_locs[,2] - centroid_y_pat
    
  }

  #Now start sequences
  rast_seq <- vector("list",length=period)
 
  T1 <- period
  if (A_seq==""){
    x<-1:T1
    T1#period
    phase<-0
    a<-1 #amplitude
    b<-0
    A_seq <-sine_structure_fun(1:T1,T1,0,1,0)
    #x <-seq(0,2*pi,by=2*pi/360)
    #x1<-sin(x)
    #n<- 360/T1
    #A_seq <-x1[ seq_along(x1) %% n == 0 ]
  }
  #if A_seq provided use the sequence

  for (k in 1:T1){
    
    r10_shifted <- shift(r10,x=coords_locs[k,1],y=coords_locs[k,2])
    #plot(r10_shifted,add=T)
    #spdf_shifted <- as(r10_shifted,"SpatialPointsDataFrame")
    spdf_shifted <- SpatialPointsDataFrame(coords=coordinates(r10_shifted),
                                     data=as.data.frame(r10_shifted))  #First put r10 at 0,0 (left botton corner) #This is already the case
    
    r_seq <-rasterize(spdf_shifted,rast_ref,"layer")*A_seq[k]
    rast_seq[[k]] <-cover(r_seq,rast_ref)
  }
  #text(x=coords_locs[,1],y=coords_locs[,2],1:12)
  rast_seq <-stack(rast_seq)
  
  ## Step 4: Add sequence to the empty stack...
  
  #Now combine with r_stack with using timing of event
  for(k in 1:length(temp_event)){
    timing<-temp_event[k]
    for (i in 1:nlayers(rast_seq)){
      r_seq <- subset(rast_seq,i)
      r_stack <-setValues(r_stack,values(r_seq),timing-1+i) #choose layer from stack and set values...
    }
  }
  
  #now write out stack...add default option later...
  #if(file_format==".tif"){
  #  raster_name<-paste("raster","_",row, "r_", col,"c_","ts_",k,"_",out_suffix,file_format, sep="")
  #  #writeRaster(r_comb, NAflag=NA_flag_val,filename=raster_name,bylayer=FALSE,bandorder="BSQ",overwrite=TRUE)
  #  writeRaster(r_temp, NAflag=NA_flag_val,filename=raster_name,bylayer=TRUE,bandorder="BSQ",overwrite=TRUE)   
  #}
  moving_ST_struct_obj <- list(rast_seq,r_stack,A_seq,trajectory)
  names(moving_ST_struct_obj) <- c("rast_seq","r_stack","A_seq","trajectory")
  return(moving_ST_struct_obj)
}

generate_spatial_trajectory <- function(rast_ref,period){
  #This function generates spatial trajectory. for spatial moving patterns. Note that the trajectory returns
  #to the initial position in all cases. The number of step in the trajectory is taken as the period.
  
  #### Input arguments:
  #period: number of time step
  
  ## Parse input arguments
  
  row_ref <- nrow(rast_ref)  
  col_ref <- ncol(rast_ref)
  proj_str <- projection(rast_ref)
  
  trajectory_list <- vector("list", length=10)
  names(trajectory_list) <- c("circle","standing_w","standing_c","standing_e","standing_n","standing_s",
                              "linear_h","linear_v","linear_diag","s_ne")
  
  ##### BEGIN SCRIPT #####
  
  ### Create default trajectory 1: circle
  
  #Create unit circle
    
  T1 <- period
    
  x <-seq(-pi,pi,by=2*pi/360)
  x1<-sin(x)
  x2<-sin(x-pi/2)
  n_step <- length(x)/T1
    
  x1 <- x1[ seq(1,length(x1),n_step )]
  x2 <- x2[ seq(1,length(x2),n_step )]
    
  x1 <- x1*col_ref/4  #rayon (radius) will be col_ref/4
  x2 <- x2*col_ref/4
    
  u1 <- x1 + col_ref/2
  v1 <- x2 + row_ref/2
    
  #rayon <- sqrt(u1^2 + v1^2) #equation for a circle radius
  #rayon must be 15 if col_ref and row_ref are equal to 60
    
  peak <- data.frame(z=rep(2,length(v1)))
  circle <- SpatialPointsDataFrame(coords=cbind(u1,v1),data=peak)  #First put r10 at 0,0 (left botton corner) #This is already the case
    
  trajectory_list[[1]] <- circle #This is the circular trajectory
    
  ### Create default trajectory 2,3,4: standing_w,standing_c,standing_e
    
  s_y_c <- (ymax(rast_ref)- ymin(rast_ref))/2
  s_x_c <- (xmax(rast_ref)- xmin(rast_ref))/2
  
  s_y_w <- s_y_c
  s_x_w <- s_x_c - (xmax(rast_ref)- xmin(rast_ref))/4 
  
  s_y_e <- s_y_c 
  s_x_e <- s_x_c + (xmax(rast_ref) + xmin(rast_ref))/4 
  
  s_y_n <- s_y_c + (ymax(rast_ref)- ymin(rast_ref))/4
  s_x_n <- s_x_c 
  s_y_s <- s_y_c - (ymax(rast_ref)- ymin(rast_ref))/4
  s_x_s <- s_x_c 
  
  s_w <- cbind(rep(s_x_w,period) , rep(s_y_w,period))
  s_c <- cbind(rep(s_x_c,period) , rep(s_y_c,period))
  s_e <- cbind(rep(s_x_e,period) , rep(s_y_e,period))
  s_n <- cbind(rep(s_x_n,period) , rep(s_y_n,period))
  s_s <- cbind(rep(s_x_s,period) , rep(s_y_s,period))
  
  peak <- data.frame(z=rep(2,period))
  s_tw <- SpatialPointsDataFrame(coords=s_w,data=peak)  
  s_tc <- SpatialPointsDataFrame(coords=s_c,data=peak)  
  s_te <- SpatialPointsDataFrame(coords=s_e,data=peak)  
  s_tn <- SpatialPointsDataFrame(coords=s_n,data=peak)  
  s_ts <- SpatialPointsDataFrame(coords=s_s,data=peak)  
  
  trajectory_list[[2]] <- s_tw #This is the standing trajectory, west side of image
  trajectory_list[[3]] <- s_tc #This is the standing trajectory, center of image
  trajectory_list[[4]] <- s_te #This is the standing trajectory, east side of image
  trajectory_list[[5]] <- s_tn #This is the standing trajectory, north of image
  trajectory_list[[6]] <- s_ts #This is the standing trajectory, south side of image
  
  ### Create default trajectory 7,8,9: linear_h,linear_v,linear_diag
  
  l_h <- s_x_e - s_x_w #linear horizontal
  l_v <- s_y_n - s_y_s #linear horizontal
  l_diag <- sqrt(l_h^2 + l_v^2) # linear diagonal is sqrt(2)*l_h
  
  #diag
  #s_y_n <- s_y_c + (ymax(rast_ref)- ymin(rast_ref))/4
  #s_x_n <- s_x_c + (xmax(rast_ref)- xmin(rast_ref))/4
  #s_y_s <- s_y_c - (ymax(rast_ref)- ymin(rast_ref))/4
  #s_x_s <- s_x_c - (xmax(rast_ref)- xmin(rast_ref))/4
  
  l_th <- c(seq(from=s_x_w,to=s_x_e,by=(l_h/(period/2)))[-1],rev(seq(from=s_x_w,to=s_x_e,by=(l_h/(period/2))))[-1])
  l_tv <- c(seq(from=s_y_s,to=s_y_n,by=(l_v/(period/2)))[-1],rev(seq(from=s_y_s,to=s_y_n,by=(l_v/(period/2))))[-1])
  #l_tdiag <- c(seq(from=s_y_s,to=s_y_n,by=(l_v/(period/2)))[-1],rev(seq(from=s_y_s,to=s_y_n,by=(l_v/(period/2))))[-1])
  
  l_th <- SpatialPointsDataFrame(coords=cbind(rep(s_x_c,times=period),l_th),data=peak)  
  l_tv <- SpatialPointsDataFrame(coords=cbind(l_tv,rep(s_y_c,times=period)),data=peak)  
  #l_tdiag <- SpatialPointsDataFrame(coords=cbind(l_tv,s_y_c),data=peak)  
  
  #add diagonal later...
  trajectory_list[[7]] <- l_th #This is the linear trajectory, horizontal form West to East
  trajectory_list[[8]] <- l_tv #This is the standing trajectory, vertical from
  #trajectory_list[[9]] <- l_tdiag #This is the standing trajectory, south side of image
  
  ### Create default trajectory 10: s-shape spatial indexing trajectory from top right without aggregation
  
  rast_ref_id <- rast_ref
  
  #add option aggregate?
  values(rast_ref_id) <- 1:ncell(rast_ref)
  seq_row<-1:row_ref
  seq_row <- seq_row[seq(1, length(seq_row), 2)]
  for(i in seq_row){
    v <- cellFromRow(rast_ref_id, rownr=i)
    rast_ref_id[i,1:col_ref] <-rev(v)
  }
  df<- cbind(as.data.frame(coordinates(rast_ref_id)),as.data.frame(rast_ref_id))
  #df<-as.data.frame(rast_ref_id,xy=TRUE) #not in hte current version
  df<-df[order(df[,c("layer")]),] #order of sequence in the s-shape from toprigth corner
  s_ne <- SpatialPointsDataFrame(as.matrix(df[,c("x","y")]),data=df) 
  trajectory_list[[10]] <- s_ne #This is the s-shape trajectory starting top right corner of image
  
  ### Prepare return object
  #the output is a list of SpationPointsDataFrame object  
  return(trajectory_list)  
}

plot_time_space_pattern<-function(time_pattern,rast_spat,out_suffix){
  layout_m<-c(1,2) #one row two columns
  par(mfrow=layout_m)

  plot(temp_pattern,type="b",main=paste("Temporal pattern",out_suffix,sep=" "))
  plot(rast_spat,main=paste("Spatial base pattern",out_suffix,sep=" "))
  
  png(paste("Figure__spatial_and_time_",out_suffix,".png", sep=""),
      height=480*layout_m[1],width=480*layout_m[2])
  
  plot(temp_pattern,type="b",main=paste("Temporal pattern",out_suffix,sep=" "))
  plot(rast_spat,main=paste("Spatial base pattern",out_suffix,sep=" "))
  dev.off()
  
  #out_dir <-paste("",out_suffix,sep="") #add string later  
  #if (!file.exists(out_dir)){    #create output directory if necessary...
  #  dir.create(out_dir)
  #  #} else{
  #  #  out_dir <-paste(out_dir..)
  #}
  
  
}

sine_structure_fun <-function(x,T,phase,a,b){
  #Create sine for a one dimensional series
  #Note that sine function uses radian unit.
  #a=amplitude
  #b=mean or amplitude 0 of the series
  #T= stands for period definition
  #phase=phase angle (in radian!!)
  
  y <- a*sin((x*pi/T)+ phase) + b
}

create_idrisi_rgf <- function(out_suffix_s,file_pat="",in_dir=".",out_prefix="",ending=FALSE){
  #create a list of raster idrisi  files...
  #out_suffix_s: ending pattern to wich .rst is attached
  #file_pat: string found in the list of files in what ever place
  if(file_pat==""){
    list_raster_name <- list.files(path=in_dir,pattern=paste(out_suffix_s,".*.rst$",sep=""),full.names=F)
  }else{
    list_raster_name <- list.files(path=in_dir,pattern=file_pat,full.names=F)
  }
  if(ending==TRUE){
    list_raster_name <- grep(paste(out_suffix_s,".rst$",sep=""),list_raster_name,value=TRUE)
  }
  dat_list<-c(as.integer(length(list_raster_name)),mixedsort(unlist(list_raster_name)))
  dat_list <- sub("[.][^.]*$", "", dat_list, perl=TRUE) #remove extension using regular expression
  writeLines(dat_list,con=file.path(in_dir,paste(out_prefix,out_suffix_s,".rgf",sep="")))
  
  return(file.path(in_dir,list_raster_name))
}

create_raster_list_from_file_pat <- function(out_suffix_s,file_pat="",in_dir=".",out_prefix="",file_format=".rst"){
  #create a list of raster files to creater R raster stacks
  if(file_pat==""){
    list_raster_name <- list.files(path=in_dir,pattern=paste(out_suffix_s,".*",file_format,"$",sep=""),full.names=T)
  }else{
    list_raster_name <- list.files(path=in_dir,pattern=file_pat,full.names=T)
  }
  dat_list<-c(mixedsort(unlist(list_raster_name)))
  #dat_list <- sub("[.][^.]*$", "", dat_list, perl=TRUE) 
  #writeLines(dat_list,con=paste(out_prefix,out_suffix_s,".rgf",sep=""))
  return(dat_list)
}

########## END OF SCRIPT ############## 
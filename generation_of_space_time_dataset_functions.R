########################################       Generation of space-time dataset       #######################################
########################################### For Testing MSSA-MEOT and S-T mode PCA #####################################
#This script contains function to generate synthetic space time dataset in R to test EOT,MEOT,PCA and MSSA.
#Space-time series can be generated by combining a set of spatial patterns and temporal patterns. 
#Parent code to run functions is found in "generation_of_space_time_dataset_08262013v5.R"
#AUTHORS:Benoit Parmentier                                             
#DATE: 08/26/2013                                                                                
#PROJECT: Clark Labs, MEOT, time series                                  
###################################################################################################

###Loading R library and packages                                                      

library(gtools)                                        # loading some useful tools 
library(sp)
library(raster)
library(rasterVis)
library(rgdal)
library(vegan) 
library(zoo)

##### Functions used in the script: "generation_of_space_time_dataset_08262013v5.R" #####

##Function to generate spatial image

generate_raster_region <-function(j,list_param){
  #This....
  #Arguments: no of image, no of rows and columns, projection, range of value to be used, distribution, output prefix, and output directory
  #Output: raster image in IDRISI format
  
  ## Parse input arguments
  
  j <- list_param$j
  col <- list_param$col
  row <- list_param$row
  proj_str <- list_param$proj_str
  range_val <- list_param$range_val
  distribution_val_i <- list_param$distribution_val_i
  out_suffix <- list_param$out_suffix
  out_dir <-list_param$out_dir
  list_param$NA_flag_val
  
  ## Start #
  
  if(distribution_val_i=="none"){
    pix_values <- rep(1,row*col)
  }
  if(distribution_val_i=="unif"){
    pix_values <- runif(row*col)
  }
  
  r<-raster(nrows=row, ncols=col,crs=proj_str,xmn=0, xmx = col, ymn=0, ymx=row)
  r <- setValues(r,pix_values)
  
  #Write out the raster defining the region
  raster_name<-paste("reg_raster","_",row, "r_", col,"c_",out_suffix, sep="")
  writeRaster(r, filename=raster_name,NAflag=NA_flag_val,bylayer=FALSE,bandorder="BSQ",overwrite=TRUE)  #Writing the data in a raster file format...  
  #return raster defining the extent and basis layer!!!
  return(r)
}

#Function to generate spatial structure
adding_sptatial_structure  <-function(j,list_param){
  
  #This....
  #Arguments: no of image, no of rows and columns, projection, range of value to be used, type of spatial pattern, output prefix, and output directory
  #Output: raster image in IDRISI format  
  #TO DO: modify for memory efficiency, write out individual raster images if necessary. 
  #Functions used in this code:
  
  sine_structure_fun <-function(x,T,phase,a,b){
    #Create sine for a one dimensional series
    #Note that sine function uses radian unit.
    #a=amplitude
    #b=mean or amplitude 0 of the series
    #T= stands for period definition
    #phase=phase angle (in radian!!)
    
    y <- a*sin((x*pi/T)+ phase) + b
  }
  
  ## Parse input arguments
  
  j <- list_param$j
  r <- list_param$r
  proj_str <- list_param$proj_str
  range_val <- list_param$range_val
  NA_flag_val <- list_param$NA_flag_val
  file_format <- list_param$file_format #".tif" or ".rst" for the time being
  #type_spatialstructure <- list_param$type_spatialstructure
  out_suffix <- list_param$out_suffix
  out_dir <-list_param$out_dir
  r <- list_param$r
  row <- nrow(r)  
  col<- ncol(r)
  
  ### Start #####
  
  type_spatialstructure <- character (length=15) #empty char vector to store names of spatial structures/raster layers 
  #Generate first spatial pattern: constant square   
  spstr<- r  
  type_spatialstructure[1] <- "constant_sqr"
  pix_values <- min(range_val)
  spstr <- setValues(spstr,pix_values)
  spstr[1:(row/2), 1:(col/2)] <- max(range_val)
  spstr[(row/2)+1:row, (col/2)+1:col] <- max(range_val)
  r1 <- spstr 
  
  #Generate spatial pattern 2: sine diagonal   
  type_spatialstructure[2] <- "sine_diag1" 
  pix_values <- min(range_val)
  spstr <- setValues(spstr,pix_values)
  x.coord <- rep(1:col, each=col)
  y.coord <- rep(1:row, times=row)
  xy <- data.frame(x.coord, y.coord)
  xy.dist <- dist(xy)
  pcnm.axes <- pcnm(xy.dist)$vectors
  z.value <- pcnm.axes[,1]*100 + rnorm(row*col, min(range_val), max(range_val))
  spstr[] <- z.value
  r2 <- spstr
  
  #Generate spatial pattern 3: trend in x    
  type_spatialstructure[3] <-"trend_x"
  u <-xFromCol(r,colnr=1:col)
  a<- 2 #slope
  b<- -1 #intercept
  ux <-  a*u + b  
  ux <-rep(ux,time=row)  
  r3<-setValues(r,ux)  
  
  #Generate spatial pattern 4: trend in y    
  type_spatialstructure[4] <-"trend_y"
  r4 <-t(r3)
  
  #Generate spatial pattern 5:     
  type_spatialstructure[5] <- "periodic_x1"
  u <- xFromCol(r,colnr=1:col)
  a<- 2 #amplitude in this case
  b<- 0
  T<- col
  phase <- 0
  ux <- sine_structure_fun(u,T,phase,a,b)
  ux <-rep(ux,time=row)  
  r5<-setValues(r,ux)  
  plot(r5)
  
  #Generate spatial pattern6:  
  type_spatialstructure[6] <- "periodic_y1"
  r6 <-t(r5)
  
  #Generate spatial pattern7:  
  type_spatialstructure[7] <- "periodic_xy1"
  r7 <- r5 + r6
  
  #Generate spatial pattern 8:     
  type_spatialstructure[8] <- "periodic_x2"
  u <- xFromCol(r,colnr=1:col)
  a<- 2 #amplitude in this case
  b<- 0
  T<- round(col/2)
  phase <- 0  
  ux <- sine_structure_fun(u,T,phase,a,b)
  ux <-rep(ux,time=row)  
  r8 <-setValues(r,ux)  

  #Generate spatial pattern 9:  
  type_spatialstructure[9] <- "periodic_y2"
  r9 <- t(r8)
  
  #Generate spatial pattern 10:  
  type_spatialstructure[10] <- "periodic_xy2"
  r10 <- r8 + r9
    
  #Generate spatial pattern 11:     
  type_spatialstructure[11] <- "periodic_x3"
  u <- xFromCol(r,colnr=1:col)
  a<- 2 #amplitude in this case, should be an argument of the function
  b<- 0
  T<- round(col/3)
  phase <- 0  
  ux <- sine_structure_fun(u,T,phase,a,b)
  ux <-rep(ux,time=row)  
  r11 <-setValues(r,ux)  
  
  #Generate spatial pattern 12:  
  type_spatialstructure[12] <- "periodic_y3"
  r12 <- t(r11)
  
  #Generate spatial pattern 13:  
  type_spatialstructure[13] <- "periodic_xy3"
  r13 <- r11 + r12
  
  #Generate spatial pattern 14:  
  type_spatialstructure[14] <- "constant" #This may contain randomness!!
  r14 <-r 
  
  #Generate spatial pattern 15: trend in xy, diagonal   
  type_spatialstructure[15] <-"trend_xy"
  r15 <- r3 + r4
  
  #TO DO later - Generate user defined patter: using a,b,phase and other inputs
  
  #Prepare stack to return object
  r_spat <-stack(r1,r2,r3,r4,r5,r6,r7,r8,r9,r10,r11,r12,r13,r14,r15)
  #names(r_spat) <- type_Spatialstructure
  layerNames(r_spat) <- type_spatialstructure
  
  #Write out spatial patterns
  if(file_format==".rst"){
    for (i in 1:nlayers(r_spat)){
      rast <-subset(r_spat,i)
      raster_name<-paste("raster","_",row, "r_", col,"c_","r_spat_s_",i,"_",
                         type_spatialstructure[i],"_",out_suffix,file_format, sep="")
      writeRaster(rast, NAflag=NA_flag_val,filename=raster_name,bylayer=FALSE,bandorder="BSQ",overwrite=TRUE)
    }
  }
  #now write out stack...
  if(file_format==".tif"){
  raster_name<-paste("raster","_",row, "r_", col,"c_","r_spat_s","_",out_suffix,file_format, sep="")
  writeRaster(r_spat, NAflag=NA_flag_val,filename=raster_name,bylayer=TRUE,bandorder="BSQ",overwrite=TRUE)   
  }

  return(r_spat)
}

#Function ....
adding_temporal_structure <-function(list_param){
  #This....
  #Arguments: no of image, no of rows and columns, projection, range of value to be used, type of spatial pattern, output prefix, and output directory
  #Output: raster image in IDRISI format  
  
  ##Functions used:
  
  temp_structure_fun <-function(x,T,phase){
    y <-sin((x*pi/T)+ phase)
  }
  
  ## Parse input arguments
  #j <- list_param$j
  nt <- list_param$nt
  phase <- list_param$phase
  temp_periods <- list_param$temp_periods
  temp_period_quadrature <- list_param$temp_period_quadrature
  
  ### Start #####
  
  #type_temporalstructure <- character (length=6)
  x<- as.numeric(1:nt)
  
  # Generate temporal signal with periodic signal
  
  y1_list<-vector("list",length=length(temp_periods))
  for (i in 1:length(temp_periods)){
    T<-temp_periods[i]
    y1_list[[i]] <- temp_structure_fun(x,T,phase)
  }
  names(y1_list) <- paste("t_period",temp_periods,sep="_")
  # Generate periodic Quadrature:
  
  T <- temp_period_quadrature
  y2_list<-vector("list",length=length(temp_periods))
  y2_list[[1]] <- temp_structure_fun(x,T,pi/2)
  y2_list[[2]] <- temp_structure_fun(x,T,0)
  
  y2<-y2_list[[1]] + y2_list[[2]]
  
  # Generate temporal trends
  a<- 0.1
  b<- 0
  y3 <-  a*x + b  
  
  # Generate temporal temporal randomness
  y4 <- runif(nt) 
  
  y5<- rnorm(nt)
  
  #Prepare return object
  dfrm1 <-do.call(cbind,y1_list)
  dfrm2 <- do.call(cbind,list(quadrature=y2,trend=y3,unif=y4,norm=y5))
  temp_pattern_dfrm <- (cbind(dfrm1,dfrm2)) #data.frame containing temporal patterns...
  temp_pattern_dfrm<-as.data.frame(temp_pattern_dfrm)
  #head(temp_pattern_dfrm)
  file_name<-paste("table_temporal_patterns","_",out_suffix,".txt",sep="")
  write.table(temp_pattern_dfrm,file=file_name,sep=",")
  
  return(temp_pattern_dfrm)
}

#generate stack given a raster image, this replicates the original image...
generate_stack_raster<-function(r,n_stack){
  pix_vals <-getValues(r)
  list_r<-vector("list",length=n_stack)
  for (i in 1:n_stack){
    list_r[[i]]<-r
  }
  r_stack<-stack(list_r)
}

#Function to combine time and space structure, given a stack of value and temporal index
combine_space_time_structure <-function(temp_pattern,r_stack,out_suffix,NA_flag_val,file_format,operation="addition"){
  #modify later for efficiency if needed, this is a small image!!!
  rast_ref <- raster(r_stack,1)
  r_list <-vector("list",length=nlayers(r_stack)) #contain rasters...
  list_raster_name <-vector("list",length=nlayers(r_stack)) #contain rasters...
  
  names(r_list) <- paste("ts",1:nlayers(r_stack),sep="_") #use names in new raster package
  for (k in 1:nlayers(r_stack)){
    pix_vals <-getValues(subset(r_stack,k))
    if(operation=="multiplication"){
      r_comb <- setValues(rast_ref,pix_vals*temp_pattern[k]) 
    }
    if(operation=="addition"){
      r_comb <- setValues(rast_ref,pix_vals+temp_pattern[k]) 
    }
    r_list[[k]] <- r_comb
    if(file_format==".rst"){
      raster_name<-paste("raster","_",row, "r_", col,"c_","ts_",k,"_",out_suffix,file_format, sep="")
      list_raster_name[[k]] <- raster_name
      writeRaster(r_comb, NAflag=NA_flag_val,filename=raster_name,bylayer=FALSE,bandorder="BSQ",overwrite=TRUE)
    }
  }
  r_temp <- stack(r_list)
  dat_list<-c(as.integer(length(list_raster_name)),unlist(list_raster_name))
  writeLines(dat_list,con=paste(out_suffix_s,".rgf",sep=""))
  
  #now write out stack...
  if(file_format==".tif"){
    raster_name<-paste("raster","_",row, "r_", col,"c_","ts_",k,"_",out_suffix,file_format, sep="")
    #writeRaster(r_comb, NAflag=NA_flag_val,filename=raster_name,bylayer=FALSE,bandorder="BSQ",overwrite=TRUE)
    writeRaster(r_temp, NAflag=NA_flag_val,filename=raster_name,bylayer=TRUE,bandorder="BSQ",overwrite=TRUE)   
  }
  return(r_temp)
}

#Add moving spatial pattern function here...
#...
#combine sine in x and y in small window
#Create sequence with position on a circle...(if 12, divide circle in 12 location)
#combine sequence with r stack with specific time event...
#generate_moving_space_time_structure <-function(rast_ref,rast_pattern="",temp_event,period,out_suffix,NA_flag_val,file_format,option="addition"){
generate_moving_space_time_structure <-function(list_param){
    
  sine_structure_fun <-function(x,T,phase,a,b){
    #Create sine for a one dimensional series
    #Note that sine function uses radian unit.
    #a=amplitude
    #b=mean or amplitude 0 of the series
    #T= stands for period definition
    #phase=phase angle (in radian!!)
    
    y <- a*sin((x*pi/T)+ phase) + b
  }
  
  ## Parse input arguments
  
  r_stack <- list_param$r_stack
  temp_period<-list_param$temp_period
  period <- list_param$period
  NA_flag_val <- list_param$NA_flag_val
  file_format <- list_param$file_format #".tif" or ".rst" for the time being
  #type_spatialstructure <- list_param$type_spatialstructure
  out_suffix <- list_param$out_suffix
  out_dir <-list_param$out_dir
  rast_pattern <- list_param$rast_pattern #moving spatial pattern provided
  A_seq <-list_param$A_seq
  #moving spatial pattern provided
  rast_ref <-subset(r_stack,1)
  row_ref <- nrow(rast_ref)  
  col_ref <- ncol(rast_ref)
  proj_str <- projection(rast_ref)
  
  ### Step 1: Generate default spatial pattern or used raster provided:  
  if(rast_pattern==""){
    row <- round(row_ref/2)
    col <- round(col_ref/2)
    
    pix_values <- rep(1,row*col)
    
    r<-raster(nrows=row, ncols=col,crs=proj_str,xmn=0, xmx = col, ymn=0, ymx=row)
    r <- setValues(r,pix_values)
    
    u <- xFromCol(r,colnr=1:col)
    a<- 2 #amplitude in this case
    b<- 0
    T<- round(col)
    phase <- 0  
    ux <- sine_structure_fun(u,T,phase,a,b)
    ux <-rep(ux,time=row)  
    r8 <-setValues(r,ux)  
    plot(r8)
    #Generate spatial pattern 9:  
    r9 <- t(r8)
    #Generate spatial pattern 10:  
    r10 <- r8 + r9
    levelplot(r10)
    #### end of generate spatial pattern  
  }else{
    r10<-rast_pattern
  }
  
  ##Step 2 generate spatial trajectory
  
  #Can be an option for later ...
  #if(trajectory==""){
  #  
  #}
  #Create unit circle
  T1 <- period

  x <-seq(-pi,pi,by=2*pi/360)
  x1<-sin(x)
  x2<-sin(x-pi/2)
  n_step <- length(x)/T1
  #n_step <- round(length(x1)/T1)
  #x1<-x1[ seq_along(x1) %% n_step == 0 ]
  #x2<-x2[ seq_along(x2) %% n_step == 0 ]

  x1 <- x1[ seq(1,length(x1),n_step )]
  x2 <- x2[ seq(1,length(x2),n_step )]
  
  u1 <- sqrt(col_ref/2)*x1 + col_ref/2
  v1 <- sqrt(row_ref/2)*x2 + row_ref/2
  
  #v1<-v1[ seq_along(v1) %% n_step == 0 ]
  #u1<-u1[ seq_along(u1) %% n_step == 0 ]
  
  peak <- data.frame(z=rep(2,length(v1)))
  circle <- SpatialPointsDataFrame(coords=cbind(u1,v1),data=peak)
  #First put r10 at 0,0 (left botton corner) #This is already the case
  
  ## Step 3: generate sequence: if period>12 then it will spread over more than a year...
  extent_pat <- extent(r10)
  
  #Calculate projection parameters
  centroid_y_pat <- (ymax(extent_pat)- ymin(extent_pat))/2
  centroid_x_pat <- (xmax(extent_pat)- xmin(extent_pat))/2

  coords_locs<-coordinates(circle)
  coords_locs[,1] <- coords_locs[,1] - centroid_x_pat
  coords_locs[,2] <- coords_locs[,2] - centroid_y_pat

  #Now start sequences
  rast_seq <- vector("list",length=T1)
 
  T1 <- period
  if (A_seq==""){
    x<-1:T1
    T1#period
    phase<-0
    a<-1 #amplitude
    b<-0
    A_seq <-sine_structure_fun(1:T1,T1,0,1,0)
    #x <-seq(0,2*pi,by=2*pi/360)
    #x1<-sin(x)
    #n<- 360/T1
    #A_seq <-x1[ seq_along(x1) %% n == 0 ]
  }
  #if A_seq provided use the sequence

  for (k in 1:T1){
    
    r10_shifted <- shift(r10,x=coords_locs[k,1],y=coords_locs[k,2])
    #plot(r10_shifted,add=T)
    spdf_shifted <- as(r10_shifted,"SpatialPointsDataFrame")
    r_seq <-rasterize(spdf_shifted,rast_ref,"layer")*A_seq[k]
    rast_seq[[k]] <-cover(r_seq,rast_ref)
  }
  #text(x=coords_locs[,1],y=coords_locs[,2],1:12)
  rast_seq <-stack(rast_seq)
  
  ## Step 4: Add sequence to the empty stack...
  
  #Now combine with r_stack with using timing of event
  for(k in 1:length(temp_event)){
    timing<-temp_event[k]
    for (i in 1:nlayers(rast_seq)){
      r_seq <- subset(rast_seq,i)
      r_stack <-setValues(r_stack,values(r_seq),timing-1+i) #choose layer from stack and set values...
    }
  }
  
  #now write out stack...
  #if(file_format==".tif"){
  #  raster_name<-paste("raster","_",row, "r_", col,"c_","ts_",k,"_",out_suffix,file_format, sep="")
  #  #writeRaster(r_comb, NAflag=NA_flag_val,filename=raster_name,bylayer=FALSE,bandorder="BSQ",overwrite=TRUE)
  #  writeRaster(r_temp, NAflag=NA_flag_val,filename=raster_name,bylayer=TRUE,bandorder="BSQ",overwrite=TRUE)   
  #}
  return(r_stack)
}

plot_time_space_pattern<-function(time_pattern,rast_spat,out_suffix){
  layout_m<-c(1,2) #one row two columns
  par(mfrow=layout_m)

  plot(temp_pattern,type="b")
  plot(rast_spat)
  
  png(paste("Figure__spatial_and_time_",out_suffix,".png", sep=""),
      height=480*layout_m[1],width=480*layout_m[2])
  
  plot(temp_pattern,type="b")
  plot(rast_spat)
  dev.off()
  
}

sine_structure_fun <-function(x,T,phase,a,b){
  #Create sine for a one dimensional series
  #Note that sine function uses radian unit.
  #a=amplitude
  #b=mean or amplitude 0 of the series
  #T= stands for period definition
  #phase=phase angle (in radian!!)
  
  y <- a*sin((x*pi/T)+ phase) + b
}

create_idrisi_rgf <- function(out_suffix_s,file_pat="",in_dir=".",out_prefix=""){
  #create a list of raster idrisi  files...
  if(file_pat==""){
    list_raster_name <- list.files(path=in_dir,pattern=paste(out_suffix_s,".*.rst$",sep=""),full.names=T)
  }else{
    list_raster_name <- list.files(path=in_dir,pattern=file_pat,full.names=T)
  }
  dat_list<-c(as.integer(length(list_raster_name)),mixedsort(unlist(list_raster_name)))
  dat_list <- sub("[.][^.]*$", "", dat_list, perl=TRUE) #remove extension using regular expression
  writeLines(dat_list,con=paste(out_prefix,out_suffix_s,".rgf",sep=""))
  return(dat_list)
}

create_raster_list_from_file_pat <- function(out_suffix_s,file_pat="",in_dir=".",out_prefix="",file_format=".rst"){
  #create a list of raster files to creater R raster stacks
  if(file_pat==""){
    list_raster_name <- list.files(path=in_dir,pattern=paste(out_suffix_s,".*",file_format,"$",sep=""),full.names=T)
  }else{
    list_raster_name <- list.files(path=in_dir,pattern=file_pat,full.names=T)
  }
  dat_list<-c(mixedsort(unlist(list_raster_name)))
  #dat_list <- sub("[.][^.]*$", "", dat_list, perl=TRUE) 
  #writeLines(dat_list,con=paste(out_prefix,out_suffix_s,".rgf",sep=""))
  return(dat_list)
}
########## END OF SCRIPT ############## 